"use strict";
var $foreign = require("./foreign");
var Data_Foldable = require("Data.Foldable");
var Prelude = require("Prelude");
var Data_Maybe = require("Data.Maybe");
var Control_Monad_Eff = require("Control.Monad.Eff");
var $tilde$greater = function (__dict_Functor_0) {
    return Prelude.flip(Prelude["<$>"](__dict_Functor_0));
};
var $tilde = function (__dict_Apply_1) {
    return Prelude["<*>"](__dict_Apply_1);
};
var $less$tilde = function (__dict_Functor_2) {
    return Prelude["<$>"](__dict_Functor_2);
};

/**
 *  |Takes a signal of effects of `a`, and produces an effect which returns a
 *  |signal which will take each effect produced by the input signal, run it,
 *  |and yield its returned value.
 */
var unwrap = $foreign.unwrapP($foreign.constant);

/**
 *  |Creates a signal which yields the current value of the second signal every
 *  |time the first signal yields.
 */
var sampleOn = $foreign.sampleOnP($foreign.constant);

/**
 *  |Merge two signals, returning a new signal which will yield a value
 *  |whenever either of the input signals yield. Its initial value will be
 *  |that of the first signal.
 */
var merge = $foreign.mergeP($foreign.constant);

/**
 *  |Merge all signals inside a `Foldable`, returning a `Maybe` which will
 *  |either contain the resulting signal, or `Nothing` if the `Foldable`
 *  |was empty.
 */
var mergeMany = function (__dict_Functor_3) {
    return function (__dict_Foldable_4) {
        return function (sigs) {
            var mergeMaybe = function (_572) {
                return function (_573) {
                    if (_573 instanceof Data_Maybe.Nothing) {
                        return _572;
                    };
                    if (_572 instanceof Data_Maybe.Nothing) {
                        return _573;
                    };
                    if (_572 instanceof Data_Maybe.Just && _573 instanceof Data_Maybe.Just) {
                        return new Data_Maybe.Just(merge(_572.value0)(_573.value0));
                    };
                    throw new Error("Failed pattern match at bower_components/purescript-signal/src/Signal.purs line 52, column 9 - line 53, column 9: " + [ _572.constructor.name, _573.constructor.name ]);
                };
            };
            return Data_Foldable.foldl(__dict_Foldable_4)(mergeMaybe)(Data_Maybe.Nothing.value)(Prelude["<$>"](__dict_Functor_3)(Data_Maybe.Just.create)(sigs));
        };
    };
};
var semigroupSignal = new Prelude.Semigroup(merge);
var mapSig = $foreign.mapSigP($foreign.constant);
var functorSignal = new Prelude.Functor(mapSig);

/**
 *  |Creates a past dependent signal. The function argument takes the value of
 *  |the input signal, and the previous value of the output signal, to produce
 *  |the new value of the output signal.
 */
var foldp = $foreign.foldpP($foreign.constant);

/**
 *  |Takes a signal and filters out yielded values for which the provided
 *  |predicate function returns `false`.
 */
var filter = $foreign.filterP($foreign.constant);

/**
 *  |Map a signal over a function which returns a `Maybe`, yielding only the
 *  |values inside `Just`s, dropping the `Nothing`s.
 */
var filterMap = function (f) {
    return function (def) {
        return function (sig) {
            return Prelude["<$>"](functorSignal)(Data_Maybe.fromMaybe(def))(filter(Data_Maybe.isJust)(new Data_Maybe.Just(def))(Prelude["<$>"](functorSignal)(f)(sig)));
        };
    };
};

/**
 *  |Create a signal which only yields values which aren't equal to the previous
 *  |value of the input signal, using JavaScript's `!==` operator to determine
 *  |disequality.
 */
var dropRepeats$prime = $foreign.dropRepeatsRefP($foreign.constant);

/**
 *  |Create a signal which only yields values which aren't equal to the previous
 *  |value of the input signal.
 */
var dropRepeats = function (__dict_Eq_5) {
    return $foreign.dropRepeatsP(__dict_Eq_5)($foreign.constant);
};
var applySig = $foreign.applySigP($foreign.constant);
var applySignal = new Prelude.Apply(function () {
    return functorSignal;
}, applySig);
var map2 = function (f) {
    return function (a) {
        return function (b) {
            return $tilde(applySignal)($less$tilde(functorSignal)(f)(a))(b);
        };
    };
};
var map3 = function (f) {
    return function (a) {
        return function (b) {
            return function (c) {
                return $tilde(applySignal)($tilde(applySignal)($less$tilde(functorSignal)(f)(a))(b))(c);
            };
        };
    };
};
var map4 = function (f) {
    return function (a) {
        return function (b) {
            return function (c) {
                return function (d) {
                    return $tilde(applySignal)($tilde(applySignal)($tilde(applySignal)($less$tilde(functorSignal)(f)(a))(b))(c))(d);
                };
            };
        };
    };
};
var map5 = function (f) {
    return function (a) {
        return function (b) {
            return function (c) {
                return function (d) {
                    return function (e) {
                        return $tilde(applySignal)($tilde(applySignal)($tilde(applySignal)($tilde(applySignal)($less$tilde(functorSignal)(f)(a))(b))(c))(d))(e);
                    };
                };
            };
        };
    };
};
var applicativeSignal = new Prelude.Applicative(function () {
    return applySignal;
}, $foreign.constant);
module.exports = {
    "~": $tilde, 
    "~>": $tilde$greater, 
    "<~": $less$tilde, 
    filterMap: filterMap, 
    filter: filter, 
    unwrap: unwrap, 
    "dropRepeats'": dropRepeats$prime, 
    dropRepeats: dropRepeats, 
    sampleOn: sampleOn, 
    foldp: foldp, 
    mergeMany: mergeMany, 
    merge: merge, 
    functorSignal: functorSignal, 
    applySignal: applySignal, 
    applicativeSignal: applicativeSignal, 
    semigroupSignal: semigroupSignal, 
    runSignal: $foreign.runSignal, 
    constant: $foreign.constant
};
