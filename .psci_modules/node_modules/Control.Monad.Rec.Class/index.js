"use strict";
var Prelude = require("Prelude");
var Data_Identity = require("Data.Identity");
var Control_Monad_Eff_Unsafe = require("Control.Monad.Eff.Unsafe");
var Control_Monad_ST = require("Control.Monad.ST");
var Control_Monad_Eff = require("Control.Monad.Eff");
var Data_Functor = require("Data.Functor");
var Data_Either = require("Data.Either");

/**
 *  | This type class captures those monads which support tail recursion in constant stack space.
 *  |
 *  | The `tailRecM` function takes a step function, and applies that step function recursively
 *  | until a return value of type `b` is found.
 *  |
 *  | Instances are provided for standard monad transformers.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | loopWriter :: Number -> WriterT Sum (Eff (trace :: Trace)) Unit
 *  | loopWriter n = tailRecM go n
 *  |   where
 *  |   go 0 = do
 *  |     lift $ trace "Done!"
 *  |     return (Right unit)
 *  |   go n = do
 *  |     tell $ Sum n
 *  |     return (Left (n - 1))
 *  | ```
 */
var MonadRec = function (__superclass_Prelude$dotMonad_0, tailRecM) {
    this["__superclass_Prelude.Monad_0"] = __superclass_Prelude$dotMonad_0;
    this.tailRecM = tailRecM;
};

/**
 *  | This type class captures those monads which support tail recursion in constant stack space.
 *  |
 *  | The `tailRecM` function takes a step function, and applies that step function recursively
 *  | until a return value of type `b` is found.
 *  |
 *  | Instances are provided for standard monad transformers.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | loopWriter :: Number -> WriterT Sum (Eff (trace :: Trace)) Unit
 *  | loopWriter n = tailRecM go n
 *  |   where
 *  |   go 0 = do
 *  |     lift $ trace "Done!"
 *  |     return (Right unit)
 *  |   go n = do
 *  |     tell $ Sum n
 *  |     return (Left (n - 1))
 *  | ```
 */
var tailRecM = function (dict) {
    return dict.tailRecM;
};

/**
 *  | Create a tail-recursive function of two arguments which uses constant stack space.
 */
var tailRecM2 = function (__dict_MonadRec_0) {
    return function (f) {
        return function (a) {
            return function (b) {
                return tailRecM(__dict_MonadRec_0)(function (o) {
                    return f(o.a)(o.b);
                })({
                    a: a, 
                    b: b
                });
            };
        };
    };
};

/**
 *  | Create a tail-recursive function of three arguments which uses constant stack space.
 */
var tailRecM3 = function (__dict_MonadRec_1) {
    return function (f) {
        return function (a) {
            return function (b) {
                return function (c) {
                    return tailRecM(__dict_MonadRec_1)(function (o) {
                        return f(o.a)(o.b)(o.c);
                    })({
                        a: a, 
                        b: b, 
                        c: c
                    });
                };
            };
        };
    };
};
var tailRecEff = function (f) {
    return function (a) {
        var fromRight = function (_238) {
            if (_238 instanceof Data_Either.Right) {
                return _238.value0;
            };
            throw new Error("Failed pattern match at bower_components/purescript-tailrec/src/Control/Monad/Rec/Class.purs line 87, column 3 - line 88, column 3: " + [ _238.constructor.name ]);
        };
        var f$prime = Prelude["<<<"](Prelude.semigroupoidFn)(Control_Monad_Eff_Unsafe.unsafeInterleaveEff)(f);
        return function __do() {
            var _26 = f$prime(a)();
            var _25 = {
                value: _26
            };
            (function () {
                while (!(function __do() {
                    var _24 = _25.value;
                    return (function () {
                        if (_24 instanceof Data_Either.Left) {
                            return function __do() {
                                var _23 = f$prime(_24.value0)();
                                _25.value = _23;
                                return Prelude["return"](Control_Monad_Eff.applicativeEff)(false)();
                            };
                        };
                        if (_24 instanceof Data_Either.Right) {
                            return Prelude["return"](Control_Monad_Eff.applicativeEff)(true);
                        };
                        throw new Error("Failed pattern match at bower_components/purescript-tailrec/src/Control/Monad/Rec/Class.purs line 74, column 1 - line 75, column 1: " + [ _24.constructor.name ]);
                    })()();
                })()) {

                };
                return {};
            })();
            return Prelude["<$>"](Control_Monad_Eff.functorEff)(fromRight)(Control_Monad_ST.readSTRef(_25))();
        };
    };
};

/**
 *  | Create a pure tail-recursive function of one argument
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | pow :: Number -> Number -> Number
 *  | pow n p = tailRec go { accum: 1, power: p }
 *  |   where
 *  |   go :: _ -> Either _ Number
 *  |   go { accum: acc, power: 0 } = Right acc
 *  |   go { accum: acc, power: p } = Left { accum: acc * n, power: p - 1 }
 *  | ```
 */
var tailRec = function (f) {
    return function (a) {
        var go = function (__copy__237) {
            var _237 = __copy__237;
            tco: while (true) {
                if (_237 instanceof Data_Either.Left) {
                    var __tco__237 = f(_237.value0);
                    _237 = __tco__237;
                    continue tco;
                };
                if (_237 instanceof Data_Either.Right) {
                    return _237.value0;
                };
                throw new Error("Failed pattern match at bower_components/purescript-tailrec/src/Control/Monad/Rec/Class.purs line 62, column 1 - line 63, column 1: " + [ _237.constructor.name ]);
            };
        };
        return go(f(a));
    };
};
var monadRecIdentity = new MonadRec(function () {
    return Data_Identity.monadIdentity;
}, function (f) {
    return Prelude["<<<"](Prelude.semigroupoidFn)(Data_Identity.Identity)(tailRec(Prelude["<<<"](Prelude.semigroupoidFn)(Data_Identity.runIdentity)(f)));
});
var monadRecEff = new MonadRec(function () {
    return Control_Monad_Eff.monadEff;
}, tailRecEff);

/**
 *  | `forever` runs an action indefinitely, using the `MonadRec` instance to
 *  | ensure constant stack usage.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | main = forever $ trace "Hello, World!"
 *  | ```
 */
var forever = function (__dict_MonadRec_2) {
    return function (ma) {
        return tailRecM(__dict_MonadRec_2)(function (u) {
            return Data_Functor["<$"]((((__dict_MonadRec_2["__superclass_Prelude.Monad_0"]())["__superclass_Prelude.Applicative_0"]())["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(new Data_Either.Left(u))(ma);
        })(Prelude.unit);
    };
};
module.exports = {
    MonadRec: MonadRec, 
    forever: forever, 
    tailRecM3: tailRecM3, 
    tailRecM2: tailRecM2, 
    tailRecM: tailRecM, 
    tailRec: tailRec, 
    monadRecIdentity: monadRecIdentity, 
    monadRecEff: monadRecEff
};
