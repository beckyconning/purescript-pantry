"use strict";
var Prelude = require("Prelude");
var Data_Monoid = require("Data.Monoid");
var Control_Alt = require("Control.Alt");
var Control_Extend = require("Control.Extend");
var Data_Bifoldable = require("Data.Bifoldable");
var Data_Bifunctor = require("Data.Bifunctor");
var Data_Bitraversable = require("Data.Bitraversable");
var Data_Foldable = require("Data.Foldable");
var Data_Traversable = require("Data.Traversable");

/**
 *  | The `Either` type is used to represent a choice between two types of value.
 *  |
 *  | A common use case for `Either` is error handling, where `Left` is used to
 *  | carry an error value and `Right` is used to carry a success value.
 */
var Left = (function () {
    function Left(value0) {
        this.value0 = value0;
    };
    Left.create = function (value0) {
        return new Left(value0);
    };
    return Left;
})();

/**
 *  | The `Either` type is used to represent a choice between two types of value.
 *  |
 *  | A common use case for `Either` is error handling, where `Left` is used to
 *  | carry an error value and `Right` is used to carry a success value.
 */
var Right = (function () {
    function Right(value0) {
        this.value0 = value0;
    };
    Right.create = function (value0) {
        return new Right(value0);
    };
    return Right;
})();

/**
 *  | The `Show` instance allows `Either` values to be rendered as a string with
 *  | `show` whenever there is an `Show` instance for both type the `Either` can
 *  | contain.
 */
var showEither = function (__dict_Show_2) {
    return function (__dict_Show_3) {
        return new Prelude.Show(function (_187) {
            if (_187 instanceof Left) {
                return "Left (" + (Prelude.show(__dict_Show_2)(_187.value0) + ")");
            };
            if (_187 instanceof Right) {
                return "Right (" + (Prelude.show(__dict_Show_3)(_187.value0) + ")");
            };
            throw new Error("Failed pattern match at bower_components/purescript-either/src/Data/Either.purs line 174, column 1 - line 181, column 1: " + [ _187.constructor.name ]);
        });
    };
};

/**
 *  | The `Functor` instance allows functions to transform the contents of a
 *  | `Right` with the `<$>` operator:
 *  |
 *  | ``` purescript
 *  | f <$> Right x == Right (f x)
 *  | ```
 *  |
 *  | `Left` values are untouched:
 *  |
 *  | ``` purescript
 *  | f <$> Left y == Left y
 *  | ```
 */
var functorEither = new Prelude.Functor(function (f) {
    return function (_182) {
        if (_182 instanceof Left) {
            return new Left(_182.value0);
        };
        if (_182 instanceof Right) {
            return new Right(f(_182.value0));
        };
        throw new Error("Failed pattern match at bower_components/purescript-either/src/Data/Either.purs line 52, column 1 - line 56, column 1: " + [ f.constructor.name, _182.constructor.name ]);
    };
});
var foldableEither = new Data_Foldable.Foldable(function (__dict_Monoid_6) {
    return function (f) {
        return function (_194) {
            if (_194 instanceof Left) {
                return Data_Monoid.mempty(__dict_Monoid_6);
            };
            if (_194 instanceof Right) {
                return f(_194.value0);
            };
            throw new Error("Failed pattern match at bower_components/purescript-either/src/Data/Either.purs line 201, column 1 - line 209, column 1: " + [ f.constructor.name, _194.constructor.name ]);
        };
    };
}, function (f) {
    return function (z) {
        return function (_193) {
            if (_193 instanceof Left) {
                return z;
            };
            if (_193 instanceof Right) {
                return f(z)(_193.value0);
            };
            throw new Error("Failed pattern match at bower_components/purescript-either/src/Data/Either.purs line 201, column 1 - line 209, column 1: " + [ f.constructor.name, z.constructor.name, _193.constructor.name ]);
        };
    };
}, function (f) {
    return function (z) {
        return function (_192) {
            if (_192 instanceof Left) {
                return z;
            };
            if (_192 instanceof Right) {
                return f(_192.value0)(z);
            };
            throw new Error("Failed pattern match at bower_components/purescript-either/src/Data/Either.purs line 201, column 1 - line 209, column 1: " + [ f.constructor.name, z.constructor.name, _192.constructor.name ]);
        };
    };
});
var traversableEither = new Data_Traversable.Traversable(function () {
    return foldableEither;
}, function () {
    return functorEither;
}, function (__dict_Applicative_1) {
    return function (_199) {
        if (_199 instanceof Left) {
            return Prelude.pure(__dict_Applicative_1)(new Left(_199.value0));
        };
        if (_199 instanceof Right) {
            return Prelude["<$>"]((__dict_Applicative_1["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Right.create)(_199.value0);
        };
        throw new Error("Failed pattern match at bower_components/purescript-either/src/Data/Either.purs line 217, column 1 - line 223, column 1: " + [ _199.constructor.name ]);
    };
}, function (__dict_Applicative_0) {
    return function (f) {
        return function (_198) {
            if (_198 instanceof Left) {
                return Prelude.pure(__dict_Applicative_0)(new Left(_198.value0));
            };
            if (_198 instanceof Right) {
                return Prelude["<$>"]((__dict_Applicative_0["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Right.create)(f(_198.value0));
            };
            throw new Error("Failed pattern match at bower_components/purescript-either/src/Data/Either.purs line 217, column 1 - line 223, column 1: " + [ f.constructor.name, _198.constructor.name ]);
        };
    };
});

/**
 *  | The `Extend` instance allows sequencing of `Either` values and functions
 *  | that accept an `Either` and return a non-`Either` result using the
 *  | `<<=` operator.
 *  |
 *  | ``` purescript
 *  | f <<= Left x = Left x
 *  | f <<= Right x = Right (f x)
 *  | ```
 */
var extendEither = new Control_Extend.Extend(function () {
    return functorEither;
}, function (f) {
    return function (_186) {
        if (_186 instanceof Left) {
            return new Left(_186.value0);
        };
        return new Right(f(_186));
    };
});

/**
 *  | The `Eq` instance allows `Either` values to be checked for equality with
 *  | `==` and inequality with `/=` whenever there is an `Eq` instance for both
 *  | types the `Either` can contain.
 */
var eqEither = function (__dict_Eq_7) {
    return function (__dict_Eq_8) {
        return new Prelude.Eq(function (_188) {
            return function (_189) {
                if (_188 instanceof Left && _189 instanceof Left) {
                    return Prelude["=="](__dict_Eq_7)(_188.value0)(_189.value0);
                };
                if (_188 instanceof Right && _189 instanceof Right) {
                    return Prelude["=="](__dict_Eq_8)(_188.value0)(_189.value0);
                };
                return false;
            };
        });
    };
};

/**
 *  | The `Ord` instance allows `Either` values to be compared with
 *  | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for
 *  | both types the `Either` can contain.
 *  |
 *  | Any `Left` value is considered to be less than a `Right` value.
 */
var ordEither = function (__dict_Ord_4) {
    return function (__dict_Ord_5) {
        return new Prelude.Ord(function () {
            return eqEither(__dict_Ord_4["__superclass_Prelude.Eq_0"]())(__dict_Ord_5["__superclass_Prelude.Eq_0"]());
        }, function (_190) {
            return function (_191) {
                if (_190 instanceof Left && _191 instanceof Left) {
                    return Prelude.compare(__dict_Ord_4)(_190.value0)(_191.value0);
                };
                if (_190 instanceof Right && _191 instanceof Right) {
                    return Prelude.compare(__dict_Ord_5)(_190.value0)(_191.value0);
                };
                if (_190 instanceof Left) {
                    return Prelude.LT.value;
                };
                if (_191 instanceof Left) {
                    return Prelude.GT.value;
                };
                throw new Error("Failed pattern match at bower_components/purescript-either/src/Data/Either.purs line 191, column 1 - line 197, column 1: " + [ _190.constructor.name, _191.constructor.name ]);
            };
        });
    };
};

/**
 *  | Takes two functions and an `Either` value, if the value is a `Left` the
 *  | inner value is applied to the first function, if the value is a `Right`
 *  | the inner value is applied to the second function.
 *  |
 *  | ``` purescript
 *  | either f g (Left x) == f x
 *  | either f g (Right y) == g y
 *  | ```
 */
var either = function (f) {
    return function (g) {
        return function (_181) {
            if (_181 instanceof Left) {
                return f(_181.value0);
            };
            if (_181 instanceof Right) {
                return g(_181.value0);
            };
            throw new Error("Failed pattern match at bower_components/purescript-either/src/Data/Either.purs line 28, column 1 - line 29, column 1: " + [ f.constructor.name, g.constructor.name, _181.constructor.name ]);
        };
    };
};

/**
 *  | Returns `true` when the `Either` value was constructed with `Left`.
 */
var isLeft = either(Prelude["const"](true))(Prelude["const"](false));

/**
 *  | Returns `true` when the `Either` value was constructed with `Right`.
 */
var isRight = either(Prelude["const"](false))(Prelude["const"](true));
var boundedEither = function (__dict_Bounded_9) {
    return function (__dict_Bounded_10) {
        return new Prelude.Bounded(new Left(Prelude.bottom(__dict_Bounded_9)), new Right(Prelude.top(__dict_Bounded_10)));
    };
};
var bifunctorEither = new Data_Bifunctor.Bifunctor(function (f) {
    return function (g) {
        return function (_183) {
            if (_183 instanceof Left) {
                return new Left(f(_183.value0));
            };
            if (_183 instanceof Right) {
                return new Right(g(_183.value0));
            };
            throw new Error("Failed pattern match at bower_components/purescript-either/src/Data/Either.purs line 56, column 1 - line 92, column 1: " + [ f.constructor.name, g.constructor.name, _183.constructor.name ]);
        };
    };
});
var bifoldableEither = new Data_Bifoldable.Bifoldable(function (__dict_Monoid_13) {
    return function (f) {
        return function (g) {
            return function (_197) {
                if (_197 instanceof Left) {
                    return f(_197.value0);
                };
                if (_197 instanceof Right) {
                    return g(_197.value0);
                };
                throw new Error("Failed pattern match at bower_components/purescript-either/src/Data/Either.purs line 209, column 1 - line 217, column 1: " + [ f.constructor.name, g.constructor.name, _197.constructor.name ]);
            };
        };
    };
}, function (f) {
    return function (g) {
        return function (z) {
            return function (_196) {
                if (_196 instanceof Left) {
                    return f(z)(_196.value0);
                };
                if (_196 instanceof Right) {
                    return g(z)(_196.value0);
                };
                throw new Error("Failed pattern match at bower_components/purescript-either/src/Data/Either.purs line 209, column 1 - line 217, column 1: " + [ f.constructor.name, g.constructor.name, z.constructor.name, _196.constructor.name ]);
            };
        };
    };
}, function (f) {
    return function (g) {
        return function (z) {
            return function (_195) {
                if (_195 instanceof Left) {
                    return f(_195.value0)(z);
                };
                if (_195 instanceof Right) {
                    return g(_195.value0)(z);
                };
                throw new Error("Failed pattern match at bower_components/purescript-either/src/Data/Either.purs line 209, column 1 - line 217, column 1: " + [ f.constructor.name, g.constructor.name, z.constructor.name, _195.constructor.name ]);
            };
        };
    };
});
var bitraversableEither = new Data_Bitraversable.Bitraversable(function () {
    return bifoldableEither;
}, function () {
    return bifunctorEither;
}, function (__dict_Applicative_12) {
    return function (_201) {
        if (_201 instanceof Left) {
            return Prelude["<$>"]((__dict_Applicative_12["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Left.create)(_201.value0);
        };
        if (_201 instanceof Right) {
            return Prelude["<$>"]((__dict_Applicative_12["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Right.create)(_201.value0);
        };
        throw new Error("Failed pattern match at bower_components/purescript-either/src/Data/Either.purs line 223, column 1 - line 227, column 36: " + [ _201.constructor.name ]);
    };
}, function (__dict_Applicative_11) {
    return function (f) {
        return function (g) {
            return function (_200) {
                if (_200 instanceof Left) {
                    return Prelude["<$>"]((__dict_Applicative_11["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Left.create)(f(_200.value0));
                };
                if (_200 instanceof Right) {
                    return Prelude["<$>"]((__dict_Applicative_11["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Right.create)(g(_200.value0));
                };
                throw new Error("Failed pattern match at bower_components/purescript-either/src/Data/Either.purs line 223, column 1 - line 227, column 36: " + [ f.constructor.name, g.constructor.name, _200.constructor.name ]);
            };
        };
    };
});

/**
 *  | The `Apply` instance allows functions contained within a `Right` to
 *  | transform a value contained within a `Right` using the `(<*>)` operator:
 *  |
 *  | ``` purescript
 *  | Right f <*> Right x == Right (f x)
 *  | ```
 *  |
 *  | `Left` values are left untouched:
 *  |
 *  | ``` purescript
 *  | Left f <*> Right x == Left x
 *  | Right f <*> Left y == Left y
 *  | ```
 *  |
 *  | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used transform a
 *  | pure function to take `Either`-typed arguments so `f :: a -> b -> c`
 *  | becomes `f :: Either l a -> Either l b -> Either l c`:
 *  |
 *  | ``` purescript
 *  | f <$> Right x <*> Right y == Right (f x y)
 *  | ```
 *  |
 *  | The `Left`-preserving behaviour of both operators means the result of
 *  | an expression like the above but where any one of the values is `Left`
 *  | means the whole result becomes `Left` also, taking the first `Left` value
 *  | found:
 *  |
 *  | ``` purescript
 *  | f <$> Left x <*> Right y == Left x
 *  | f <$> Right x <*> Left y == Left y
 *  | f <$> Left x <*> Left y == Left x
 *  | ```
 */
var applyEither = new Prelude.Apply(function () {
    return functorEither;
}, function (_184) {
    return function (r) {
        if (_184 instanceof Left) {
            return new Left(_184.value0);
        };
        if (_184 instanceof Right) {
            return Prelude["<$>"](functorEither)(_184.value0)(r);
        };
        throw new Error("Failed pattern match at bower_components/purescript-either/src/Data/Either.purs line 92, column 1 - line 116, column 1: " + [ _184.constructor.name, r.constructor.name ]);
    };
});

/**
 *  | The `Bind` instance allows sequencing of `Either` values and functions that
 *  | return an `Either` by using the `>>=` operator:
 *  |
 *  | ``` purescript
 *  | Left x >>= f = Left x
 *  | Right x >>= f = f x
 *  | ```
 */
var bindEither = new Prelude.Bind(function () {
    return applyEither;
}, either(function (e) {
    return function (_180) {
        return new Left(e);
    };
})(function (a) {
    return function (f) {
        return f(a);
    };
}));

/**
 *  | The `Applicative` instance enables lifting of values into `Either` with the
 *  | `pure` or `return` function (`return` is an alias for `pure`):
 *  |
 *  | ``` purescript
 *  | pure x :: Either _ _ == Right x
 *  | return x :: Either _ _ == Right x
 *  | ```
 *  |
 *  | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s
 *  | `pure` can be used to pass a mixture of `Either` and non-`Either` typed
 *  | values to a function that does not usually expect them, by using `pure`
 *  | for any value that is not already `Either` typed:
 *  |
 *  | ``` purescript
 *  | f <$> Right x <*> pure y == Right (f x y)
 *  | ```
 *  |
 *  | Even though `pure = Right` it is recommended to use `pure` in situations
 *  | like this as it allows the choice of `Applicative` to be changed later
 *  | without having to go through and replace `Right` with a new constructor.
 */
var applicativeEither = new Prelude.Applicative(function () {
    return applyEither;
}, Right.create);

/**
 *  | The `Monad` instance guarantees that there are both `Applicative` and
 *  | `Bind` instances for `Either`. This also enables the `do` syntactic sugar:
 *  |
 *  | ``` purescript
 *  | do
 *  |   x' <- x
 *  |   y' <- y
 *  |   pure (f x' y')
 *  | ```
 *  |
 *  | Which is equivalent to:
 *  |
 *  | ``` purescript
 *  | x >>= (\x' -> y >>= (\y' -> pure (f x' y')))
 *  | ```
 */
var monadEither = new Prelude.Monad(function () {
    return applicativeEither;
}, function () {
    return bindEither;
});

/**
 *  | The `Alt` instance allows for a choice to be made between two `Either`
 *  | values with the `<|>` operator, where the first `Right` encountered
 *  | is taken.
 *  |
 *  | ``` purescript
 *  | Right x <|> Right y == Right x
 *  | Left x <|> Right y == Right y
 *  | Left x <|> Left y == Left y
 *  | ```
 */
var altEither = new Control_Alt.Alt(function () {
    return functorEither;
}, function (_185) {
    return function (r) {
        if (_185 instanceof Left) {
            return r;
        };
        return _185;
    };
});
module.exports = {
    Left: Left, 
    Right: Right, 
    isRight: isRight, 
    isLeft: isLeft, 
    either: either, 
    functorEither: functorEither, 
    bifunctorEither: bifunctorEither, 
    applyEither: applyEither, 
    applicativeEither: applicativeEither, 
    altEither: altEither, 
    bindEither: bindEither, 
    monadEither: monadEither, 
    extendEither: extendEither, 
    showEither: showEither, 
    eqEither: eqEither, 
    ordEither: ordEither, 
    boundedEither: boundedEither, 
    foldableEither: foldableEither, 
    bifoldableEither: bifoldableEither, 
    traversableEither: traversableEither, 
    bitraversableEither: bitraversableEither
};
