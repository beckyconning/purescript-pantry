"use strict";
var Prelude = require("Prelude");
var Control_Apply = require("Control.Apply");
var Data_Monoid_Disj = require("Data.Monoid.Disj");
var Data_Monoid_Conj = require("Data.Monoid.Conj");
var Data_Monoid = require("Data.Monoid");

/**
 *  | `Bifoldable` represents data structures with two type arguments which can be
 *  | folded.
 *  |
 *  | A fold for such a structure requires two step functions, one for each type
 *  | argument. Type class instances should choose the appropriate step function based
 *  | on the type of the element encountered at each point of the fold.
 *  |
 */
var Bifoldable = function (bifoldMap, bifoldl, bifoldr) {
    this.bifoldMap = bifoldMap;
    this.bifoldl = bifoldl;
    this.bifoldr = bifoldr;
};

/**
 *  | `Bifoldable` represents data structures with two type arguments which can be
 *  | folded.
 *  |
 *  | A fold for such a structure requires two step functions, one for each type
 *  | argument. Type class instances should choose the appropriate step function based
 *  | on the type of the element encountered at each point of the fold.
 *  |
 */
var bifoldr = function (dict) {
    return dict.bifoldr;
};

/**
 *  | Traverse a data structure, accumulating effects using an `Applicative` functor,
 *  | ignoring the final result.
 */
var bitraverse_ = function (__dict_Bifoldable_0) {
    return function (__dict_Applicative_1) {
        return function (f) {
            return function (g) {
                return bifoldr(__dict_Bifoldable_0)(Prelude["<<<"](Prelude.semigroupoidFn)(Control_Apply["*>"](__dict_Applicative_1["__superclass_Prelude.Apply_0"]()))(f))(Prelude["<<<"](Prelude.semigroupoidFn)(Control_Apply["*>"](__dict_Applicative_1["__superclass_Prelude.Apply_0"]()))(g))(Prelude.pure(__dict_Applicative_1)(Prelude.unit));
            };
        };
    };
};

/**
 *  | A version of `bitraverse_` with the data structure as the first argument.
 */
var bifor_ = function (__dict_Bifoldable_2) {
    return function (__dict_Applicative_3) {
        return function (t) {
            return function (f) {
                return function (g) {
                    return bitraverse_(__dict_Bifoldable_2)(__dict_Applicative_3)(f)(g)(t);
                };
            };
        };
    };
};

/**
 *  | Collapse a data structure, collecting effects using an `Applicative` functor,
 *  | ignoring the final result.
 */
var bisequence_ = function (__dict_Bifoldable_4) {
    return function (__dict_Applicative_5) {
        return bitraverse_(__dict_Bifoldable_4)(__dict_Applicative_5)(Prelude.id(Prelude.categoryFn))(Prelude.id(Prelude.categoryFn));
    };
};

/**
 *  | `Bifoldable` represents data structures with two type arguments which can be
 *  | folded.
 *  |
 *  | A fold for such a structure requires two step functions, one for each type
 *  | argument. Type class instances should choose the appropriate step function based
 *  | on the type of the element encountered at each point of the fold.
 *  |
 */
var bifoldl = function (dict) {
    return dict.bifoldl;
};

/**
 *  | `Bifoldable` represents data structures with two type arguments which can be
 *  | folded.
 *  |
 *  | A fold for such a structure requires two step functions, one for each type
 *  | argument. Type class instances should choose the appropriate step function based
 *  | on the type of the element encountered at each point of the fold.
 *  |
 */
var bifoldMap = function (dict) {
    return dict.bifoldMap;
};

/**
 *  | Fold a data structure, accumulating values in a monoidal type.
 */
var bifold = function (__dict_Bifoldable_6) {
    return function (__dict_Monoid_7) {
        return bifoldMap(__dict_Bifoldable_6)(__dict_Monoid_7)(Prelude.id(Prelude.categoryFn))(Prelude.id(Prelude.categoryFn));
    };
};

/**
 *  | Test whether a predicate holds at any position in a data structure.
 */
var biany = function (__dict_Bifoldable_8) {
    return function (__dict_BooleanAlgebra_9) {
        return function (p) {
            return function (q) {
                return Prelude["<<<"](Prelude.semigroupoidFn)(Data_Monoid_Disj.runDisj)(bifoldMap(__dict_Bifoldable_8)(Data_Monoid_Disj.monoidDisj(__dict_BooleanAlgebra_9))(Prelude["<<<"](Prelude.semigroupoidFn)(Data_Monoid_Disj.Disj)(p))(Prelude["<<<"](Prelude.semigroupoidFn)(Data_Monoid_Disj.Disj)(q)));
            };
        };
    };
};

/**
 *  -- | Test whether a predicate holds at all positions in a data structure.
 */
var biall = function (__dict_Bifoldable_10) {
    return function (__dict_BooleanAlgebra_11) {
        return function (p) {
            return function (q) {
                return Prelude["<<<"](Prelude.semigroupoidFn)(Data_Monoid_Conj.runConj)(bifoldMap(__dict_Bifoldable_10)(Data_Monoid_Conj.monoidConj(__dict_BooleanAlgebra_11))(Prelude["<<<"](Prelude.semigroupoidFn)(Data_Monoid_Conj.Conj)(p))(Prelude["<<<"](Prelude.semigroupoidFn)(Data_Monoid_Conj.Conj)(q)));
            };
        };
    };
};
module.exports = {
    Bifoldable: Bifoldable, 
    biall: biall, 
    biany: biany, 
    bisequence_: bisequence_, 
    bifor_: bifor_, 
    bitraverse_: bitraverse_, 
    bifold: bifold, 
    bifoldMap: bifoldMap, 
    bifoldl: bifoldl, 
    bifoldr: bifoldr
};
